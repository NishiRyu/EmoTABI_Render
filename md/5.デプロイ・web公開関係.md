# EMOTABI デプロイ・Web公開ガイド

## 🚀 デプロイメント概要

EMOTABIシステムは、以下のプラットフォームでのデプロイメントをサポートしています：

1. **[Render](#render-デプロイメント)** (推奨) - メインホスティング
2. **[Railway](#railway-デプロイメント)** - 代替ホスティング  
3. **[Docker](#docker-デプロイメント)** - コンテナベース
4. **[ローカル環境](#ローカル環境構築)** - 開発・テスト用

---

## 🌟 Render デプロイメント（推奨）

### 概要

**Render**は、Dockerコンテナベースの高性能クラウドプラットフォームです。

**メリット**:
- 自動デプロイ・スケーリング
- 豊富な無料枠
- GitHub連携
- 環境変数管理
- 自動SSL/TLS

### デプロイ手順

#### **1. Renderアカウント作成**
1. [Render](https://render.com) にアクセス
2. GitHubアカウントでサインアップ
3. ダッシュボードにアクセス

#### **2. Web Serviceの作成**
1. 「New +」→「Web Service」を選択
2. GitHubリポジトリを接続
3. 設定項目を入力：

```yaml
Name: emotabi-app
Region: Oregon (US West)
Branch: main
Runtime: Docker
Build Command: (空白)
Start Command: (空白)
```

#### **3. 環境変数の設定**
```bash
OPENAI_API_KEY=your_openai_api_key
GOOGLE_MAPS_API_KEY=your_google_maps_api_key
FLASK_ENV=production
PORT=10000
```

#### **4. デプロイ実行**
1. 「Create Web Service」をクリック
2. 自動ビルド・デプロイが開始
3. ログで進行状況を確認

### Dockerfile設定

```dockerfile
FROM python:3.9-slim

WORKDIR /app

# システム依存関係のインストール
RUN apt-get update && apt-get install -y \
    libgl1-mesa-glx \
    libglib2.0-0 \
    libsm6 \
    libxext6 \
    libxrender-dev \
    libgomp1 \
    wget \
    && rm -rf /var/lib/apt/lists/*

# Python依存関係のインストール
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# アプリケーションファイルのコピー
COPY . .

# ポート設定
EXPOSE 10000

# アプリケーション起動
CMD ["python", "app.py"]
```

---

## 🚄 Railway デプロイメント

### 概要

**Railway**は、シンプルで高速なデプロイメントプラットフォームです。

**メリット**:
- ワンクリックデプロイ
- 自動スケーリング
- データベース統合
- 簡単な環境変数管理

### デプロイ手順

#### **1. Railwayアカウント作成**
1. [Railway](https://railway.app) にアクセス
2. GitHubアカウントでサインアップ

#### **2. プロジェクト作成**
1. 「New Project」をクリック
2. 「Deploy from GitHub repo」を選択
3. EMOTABIリポジトリを選択

#### **3. 環境変数設定**
```bash
OPENAI_API_KEY=your_openai_api_key
GOOGLE_MAPS_API_KEY=your_google_maps_api_key
FLASK_ENV=production
```

#### **4. 自動デプロイ**
- Railwayが自動的にDockerfileを検出
- ビルド・デプロイが自動実行
- カスタムドメインの設定可能

---

## 🐳 Docker デプロイメント

### ローカルDocker実行

#### **1. イメージビルド**
```bash
docker build -t emotabi .
```

#### **2. コンテナ実行**
```bash
docker run -p 5000:5000 \
  -e OPENAI_API_KEY=your_openai_api_key \
  -e GOOGLE_MAPS_API_KEY=your_google_maps_api_key \
  emotabi
```

### Docker Compose

#### **docker-compose.yml**
```yaml
version: '3.8'

services:
  emotabi:
    build: .
    ports:
      - "5000:5000"
    environment:
      - OPENAI_API_KEY=${OPENAI_API_KEY}
      - GOOGLE_MAPS_API_KEY=${GOOGLE_MAPS_API_KEY}
      - FLASK_ENV=production
    volumes:
      - ./uploads:/app/uploads
      - ./static:/app/static
    restart: unless-stopped
```

#### **実行コマンド**
```bash
# 環境変数ファイル作成
echo "OPENAI_API_KEY=your_key" > .env
echo "GOOGLE_MAPS_API_KEY=your_key" >> .env

# 起動
docker-compose up -d

# 停止
docker-compose down
```

---

## 💻 ローカル環境構築

### 開発環境セットアップ

#### **1. Python環境準備**
```bash
# Python 3.9+ が必要
python --version

# 仮想環境作成
python -m venv venv

# 仮想環境有効化
# Windows
venv\Scripts\activate
# Mac/Linux
source venv/bin/activate
```

#### **2. 依存関係インストール**
```bash
pip install -r requirements.txt
```

#### **3. 環境変数設定**
```bash
# .env ファイル作成
OPENAI_API_KEY=your_openai_api_key
GOOGLE_MAPS_API_KEY=your_google_maps_api_key
FLASK_ENV=development
DEBUG=True
```

#### **4. アプリケーション起動**
```bash
python app.py
```

### 開発時の注意点

- **ポート設定**: デフォルト5000番ポート
- **デバッグモード**: `DEBUG=True`で詳細ログ出力
- **ホットリロード**: ファイル変更時の自動再起動
- **静的ファイル**: `static/`ディレクトリの管理

---

## 🔧 本番環境設定

### 環境変数管理

#### **必須環境変数**
```bash
OPENAI_API_KEY=sk-xxxxxxxxxxxxxxxx  # OpenAI APIキー
GOOGLE_MAPS_API_KEY=AIzaxxxxxxxx    # Google Maps APIキー
```

#### **オプション環境変数**
```bash
FLASK_ENV=production     # 本番環境設定
DEBUG=False             # デバッグモード無効
PORT=10000              # ポート番号（Render用）
HOST=0.0.0.0           # ホストアドレス
```

### パフォーマンス最適化

#### **Gunicorn設定**
```bash
# requirements.txt に追加
gunicorn==20.1.0

# 起動コマンド
gunicorn --bind 0.0.0.0:$PORT --workers 4 app:app
```

#### **app.py 本番設定**
```python
if __name__ == '__main__':
    port = int(os.environ.get('PORT', 5000))
    host = os.environ.get('HOST', '0.0.0.0')
    debug = os.environ.get('DEBUG', 'False').lower() == 'true'
    
    app.run(host=host, port=port, debug=debug)
```

---

## 🛡️ セキュリティ設定

### HTTPS設定

#### **Render/Railway**
- 自動SSL/TLS証明書
- カスタムドメイン対応
- HTTPS強制リダイレクト

#### **独自サーバー**
```bash
# Let's Encrypt使用
sudo certbot --nginx -d yourdomain.com
```

### セキュリティヘッダー

```python
from flask import Flask
from flask_talisman import Talisman

app = Flask(__name__)

# セキュリティヘッダー設定
Talisman(app, {
    'force_https': True,
    'strict_transport_security': True,
    'content_security_policy': {
        'default-src': "'self'",
        'script-src': "'self' 'unsafe-inline'",
        'style-src': "'self' 'unsafe-inline'",
        'img-src': "'self' data: https:",
    }
})
```

---

## 📊 監視・ログ管理

### アプリケーション監視

#### **ヘルスチェック**
```python
@app.route('/health')
def health_check():
    """ヘルスチェックエンドポイント"""
    return {
        'status': 'healthy',
        'timestamp': datetime.now().isoformat(),
        'version': '1.0.0'
    }
```

#### **メトリクス収集**
```python
import logging
from datetime import datetime

# ログ設定
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)

# リクエストログ
@app.before_request
def log_request():
    app.logger.info(f'Request: {request.method} {request.path}')

@app.after_request
def log_response(response):
    app.logger.info(f'Response: {response.status_code}')
    return response
```

### エラー追跡

#### **Sentry統合**
```python
import sentry_sdk
from sentry_sdk.integrations.flask import FlaskIntegration

sentry_sdk.init(
    dsn="your-sentry-dsn",
    integrations=[FlaskIntegration()],
    traces_sample_rate=1.0
)
```

---

## 🚀 CI/CD パイプライン

### GitHub Actions設定

#### **.github/workflows/deploy.yml**
```yaml
name: Deploy to Render

on:
  push:
    branches: [ main ]

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.9'
    
    - name: Install dependencies
      run: |
        pip install -r requirements.txt
    
    - name: Run tests
      run: |
        python -m pytest tests/
    
    - name: Deploy to Render
      run: |
        curl -X POST ${{ secrets.RENDER_DEPLOY_HOOK }}
```

### 自動テスト

#### **tests/test_app.py**
```python
import pytest
from app import app

@pytest.fixture
def client():
    app.config['TESTING'] = True
    with app.test_client() as client:
        yield client

def test_health_check(client):
    """ヘルスチェックのテスト"""
    response = client.get('/health')
    assert response.status_code == 200

def test_index_page(client):
    """インデックスページのテスト"""
    response = client.get('/')
    assert response.status_code == 200
```

---

## 📈 スケーリング戦略

### 水平スケーリング

#### **Render設定**
```yaml
# render.yaml
services:
  - type: web
    name: emotabi
    runtime: docker
    plan: starter
    autoDeploy: true
    scaling:
      minInstances: 1
      maxInstances: 10
```

### 垂直スケーリング

#### **リソース最適化**
- **メモリ**: 512MB-1GB推奨
- **CPU**: 1-2コア推奨
- **ストレージ**: 10GB推奨

---

## 🔍 トラブルシューティング

### よくある問題と解決法

#### **1. ビルドエラー**
```bash
# 依存関係の問題
pip install --upgrade pip
pip install -r requirements.txt --force-reinstall

# Docker ビルドエラー
docker system prune -a
docker build --no-cache -t emotabi .
```

#### **2. メモリ不足**
```python
# 画像サイズ制限
MAX_CONTENT_LENGTH = 16 * 1024 * 1024  # 16MB

# メモリ使用量監視
import psutil
print(f"Memory usage: {psutil.virtual_memory().percent}%")
```

#### **3. API制限**
```python
# レート制限対応
import time
from functools import wraps

def rate_limit(calls_per_minute=60):
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            time.sleep(60 / calls_per_minute)
            return func(*args, **kwargs)
        return wrapper
    return decorator
```

### ログ分析

#### **重要なログポイント**
- API呼び出し回数・応答時間
- エラー発生頻度・種類
- メモリ・CPU使用率
- ユーザーアクセスパターン

---

## 📞 サポート・メンテナンス

### 定期メンテナンス

#### **週次チェック**
- [ ] APIキーの有効性確認
- [ ] ログエラーの確認
- [ ] パフォーマンス指標の確認
- [ ] セキュリティアップデートの適用

#### **月次チェック**
- [ ] 依存関係のアップデート
- [ ] バックアップの確認
- [ ] 使用量・コストの確認
- [ ] ドキュメントの更新

### 緊急時対応

#### **サービス停止時**
1. ヘルスチェックエンドポイントの確認
2. ログの確認・分析
3. 必要に応じてサービス再起動
4. 根本原因の特定・修正

#### **連絡先**
- 技術サポート: [GitHub Issues](https://github.com/your-repo/issues)
- 緊急連絡: admin@yourdomain.com
